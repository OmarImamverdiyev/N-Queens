\documentclass[11pt]{article}
\usepackage[a4paper,margin=1in]{geometry}
\usepackage{amsmath,amssymb}
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage{enumitem}

\title{N-Queens CSP Solver: Design and Implementation Report}
\author{Omar Imamverdiyev, Mehriban Aliyeva}
\date{\today}

\begin{document}
\maketitle

\begin{abstract}
This report documents the implemented N-Queens project as a practical CSP system, not only as a theoretical model. It explains how the code is organized, how min-conflicts is combined with MRV, LCV, tie-breaking, and AC-3, and how input boards are generated for testing. The focus is on actual control flow and data structures used in the repository.
\end{abstract}

\section{Project Scope}
The project solves N-Queens for board sizes in the assignment range $10 \le n \le 1000$. The solver supports two start modes:
\begin{itemize}[leftmargin=*]
  \item \textbf{Random start}: provide \texttt{--n}, generate a permutation board.
  \item \textbf{Input start}: provide \texttt{--input-file}, load a board from file.
\end{itemize}

The required CSP components are implemented:
\begin{itemize}[leftmargin=*]
  \item iterative search (min-conflicts style),
  \item MRV/LCV with explicit tie-breaking,
  \item AC-3 constraint propagation over row domains.
\end{itemize}

\section{CSP Model Used by the Code}
Each row is one variable:
\[
X_i \in \{0,1,\dots,n-1\}, \quad i=0,\dots,n-1.
\]
The value $X_i$ is the column of the queen in row $i$.

Binary constraints between each pair of rows $i \ne j$ are:
\begin{align}
X_i &\ne X_j, \\
|X_i - X_j| &\ne |i - j|.
\end{align}

This is a complete constraint graph over rows. The implementation stores complete assignments and iteratively repairs conflicts.

\section{Code Structure}
\begin{center}
\begin{tabular}{@{}ll@{}}
\toprule
File & Responsibility \\
\midrule
\texttt{main.py} & CLI parsing, mode selection, assignment-range check \\
\texttt{nqueens/csp.py} & Compatibility wrapper (\texttt{NQueensCSP}) \\
\texttt{nqueens/csp\_state.py} & Board state + O(1) conflict counters \\
\texttt{nqueens/min\_conflicts.py} & Iterative solver loop and heuristics \\
\texttt{nqueens/ac3.py} & AC-3, \texttt{revise}, arc support checks \\
\texttt{nqueens/io\_utils.py} & Input parsing with comments/blank-line support \\
\texttt{nqueens/utils.py} & Final board validator (\texttt{is\_valid}) \\
\texttt{generate\_nqueens.py} & Test/input-board generator script \\
\bottomrule
\end{tabular}
\end{center}

\section{Solver Workflow}
\subsection{Entry Point and Wrapper}
\texttt{main.py} reads arguments, enforces $10 \le n \le 1000$, and builds \texttt{NQueensCSP}. The wrapper in \texttt{nqueens/csp.py} resets state according to start mode, then calls \texttt{solve\_min\_conflicts}.

\subsection{State Representation}
\texttt{NQueensState} stores:
\begin{itemize}[leftmargin=*]
  \item \texttt{board[row] = col},
  \item \texttt{col\_count[col]},
  \item \texttt{diag1\_count[row - col + n]},
  \item \texttt{diag2\_count[row + col]}.
\end{itemize}

Conflict evaluation is O(1):
\[
\text{conflicts}(r,c)=
\text{col\_count}[c]+\text{diag1\_count}[r-c+n]+\text{diag2\_count}[r+c]-3\cdot\mathbf{1}[\text{board}[r]=c].
\]
The subtraction removes the queen's own current contribution when evaluating its present column.

\subsection{Min-Conflicts Loop}
At each step:
\begin{enumerate}[leftmargin=*]
  \item collect conflicted rows,
  \item stop if none remain,
  \item track stagnation using ``best conflicted count'' and ``stagnant steps'',
  \item apply restart/noisy escape if stalled,
  \item sample conflicted rows and build temporary domains,
  \item select row using MRV + tie-break,
  \item select value using LCV + tie-break/fallback,
  \item move one queen and update counters incrementally.
\end{enumerate}

The algorithm is stochastic in row sampling and exact-tie selection, so runtime can vary across runs.

\section{Heuristics and Propagation in the Implementation}
\subsection{MRV with Conflict-Aware Tie-Break}
MRV is applied on sampled conflicted rows, not all rows. For each sampled row:
\begin{itemize}[leftmargin=*]
  \item domain size is measured after optional AC-3,
  \item tie-break prefers larger current conflict count,
  \item exact ties are broken randomly.
\end{itemize}
This keeps variable choice focused but avoids full-board domain recomputation each iteration.

\subsection{LCV on Active Neighborhood}
For a chosen row, LCV ranks candidate columns by how many values they eliminate from neighboring sampled rows. The implementation uses fast membership checks for at most three forbidden values per neighbor (same column and two diagonals), then breaks ties by smaller column index.

\subsection{AC-3 Integration}
Domains are seeded from each row's minimum-conflict columns, capped to a small size, then optionally propagated with AC-3. Propagation is periodic and also triggered during stagnation, instead of running every step.

In \texttt{ac3.py}, support testing is optimized: if neighbor domain size is greater than three, support always exists for N-Queens pairwise constraints, so a full nested scan is unnecessary.

\section{Adaptive Parameters by Board Size}
The solver uses size-based presets to keep per-step work bounded:
\begin{center}
\begin{tabular}{@{}lllll@{}}
\toprule
Range & \texttt{sample\_size} & \texttt{domain\_cap} & \texttt{ac3\_period} & \texttt{stagnation\_limit} \\
\midrule
$n \ge 400$ & $\min(8,n)$ & $\min(6,n)$ & 6 & $\max(80,\lfloor n/2 \rfloor)$ \\
$100 \le n < 400$ & $\min(12,n)$ & $\min(8,n)$ & 4 & $\max(100,n)$ \\
$n < 100$ & $\min(30,n)$ & $\min(12,n)$ & 1 & $\max(120,6n)$ \\
\bottomrule
\end{tabular}
\end{center}

Restart budget is also bounded:
\[
\texttt{max\_restarts}=\max\left(4,\min\left(60,\frac{\texttt{max\_steps}}{\max(1,\texttt{stagnation\_limit})}\right)\right).
\]

\section{Input Handling and Validation}
\texttt{read\_input} accepts one integer per line and ignores:
\begin{itemize}[leftmargin=*]
  \item blank lines,
  \item inline comments after \texttt{\#}.
\end{itemize}

After parsing, it validates:
\begin{itemize}[leftmargin=*]
  \item file is non-empty,
  \item each column is in range $[0,n-1]$,
  \item columns form a permutation (one queen per column).
\end{itemize}

\section{Generator Script (\texttt{generate\_nqueens.py})}
\subsection{Naming Note}
The repository contains \texttt{generate\_nqueens.py}; there is no file named \texttt{generate\_npuzzle.py}.

\subsection{Purpose}
The generator creates input boards for solver experiments and debugging. It writes one column value per line, matching the parser format.

\subsection{Mode Logic and Structure}
\begin{itemize}[leftmargin=*]
  \item \textbf{\texttt{--random}}: \texttt{generate\_random\_board(n)} uses \texttt{random.sample(range(n), n)} to produce a permutation.
  \item \textbf{\texttt{--easy}}: \texttt{generate\_easy\_board(n, attempts=200)} samples many random permutations, scores each with \texttt{\_conflict\_count}, and keeps the lowest-conflict board found.
  \item \textbf{\texttt{--solution}}: \texttt{generate\_constructive\_solution(n)} returns a deterministic even-columns-then-odd-columns ordering (for even $n$ only).
  \item \textbf{\texttt{--hard-diagonal}}: returns $[0,1,\dots,n-1]$ (main diagonal).
  \item \textbf{\texttt{--hard-anti}}: returns reversed range (anti-diagonal).
\end{itemize}

\subsection{Conflict Scoring in \texttt{\_conflict\_count}}
Instead of pairwise O($n^2$) scanning, the function builds column and diagonal frequency arrays, then sums pair counts with:
\[
\binom{k}{2} = \frac{k(k-1)}{2}.
\]
This is efficient and consistent with the solver's conflict model.

\subsection{Practical Caveat}
The \texttt{--solution} mode name suggests a guaranteed solved board, but the current sequence is only a deterministic permutation pattern and should be treated as a structured start state unless separately validated.

\section{Testing Snapshot}
Unit tests in \texttt{tests/test\_nqueens.py} cover:
\begin{itemize}[leftmargin=*]
  \item file parsing and validation,
  \item AC-3 primitives (\texttt{queens\_compatible}, \texttt{revise}, \texttt{ac3}),
  \item state counter updates after moves,
  \item CSP wrapper behavior for random/input start modes.
\end{itemize}
Current suite status is 10/10 passing.

\section{Complexity and Practical Behavior}
\begin{itemize}[leftmargin=*]
  \item Conflict query and move update are O(1).
  \item Per-step search work is dominated by scanning candidate columns for sampled rows.
  \item AC-3 adds overhead but improves local pruning when triggered selectively.
  \item The approach is incomplete (local search), but practical for large $n$ with restart/noise strategies.
\end{itemize}

\section{Conclusion}
This implementation follows the CSP framing while prioritizing runtime behavior needed for larger boards. The final design combines compact state counters, adaptive min-conflicts, MRV/LCV with tie-breaking, and selective AC-3. The generator script complements the solver by creating easy, random, and adversarial starts that are useful for evaluation.

\end{document}
